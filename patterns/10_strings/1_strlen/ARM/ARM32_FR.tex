\myparagraph{ARM 32-bit}

\mysubparagraph{\NonOptimizingXcodeIV (\ARMMode)}

\lstinputlisting[caption=\NonOptimizingXcodeIV (\ARMMode),label=ARM_leaf_example7,style=customasmARM]{patterns/10_strings/1_strlen/ARM/xcode_ARM_O0_FR.asm}

%%Non-optimizing LLVM generates too much code, however, here we can see how the function works with 
%%local variables in the stack.
LLVM sans optimisation génère beaucoup trop de code, toutefois, ici nous pouvons
voir comment la fonction travaille avec les variables locales.
%%There are only two local variables in our function: \IT{eos} and \IT{str}.
Il y a seulement deux variables locales dans notre fonctions: \IT{eos} et \IT{str}.
%%In this listing, generated by \IDA, we have manually renamed \IT{var\_8} and \IT{var\_4} to \IT{eos} and \IT{str}.
Dans ce listing, généré par \IDA, nous avons renommé manuellement \IT{var\_8} et
\IT{var\_4} en \IT{eos} et \IT{str}.

%%The first instructions just saves the input values into both \IT{str} and \IT{eos}.
La première instruction sauve simplement les valeurs d'entrée dans \IT{str} et \IT{eos}.

%%The body of the loop starts at label \IT{loc\_2CB8}.
Le corps de la boucle démarre au label \IT{loc\_2CB8}.

%%The first three instruction in the loop body (\TT{LDR}, \ADD, \TT{STR}) load the value of \IT{eos} into \Reg{0}. 
Les trois première instructions du corps de la boucle (\TT{LDR}, \ADD, \TT{STR})
chargent la valeur de \IT{eos} dans \Reg{0}.
%%Then the value is \glslink{increment}{incremented} and saved back into \IT{eos}, which is located in the stack.
Puis la valeur \glslink{increment}{incrémentée} et sauvée dans \IT{eos}, qui se trouve
sur la pile.

\myindex{ARM!\Instructions!LDRSB}
%%The next instruction,  \TT{LDRSB R0, [R0]} (\q{Load Register Signed Byte}), loads a byte from memory at the address stored in \Reg{0} and sign-extends it to 32-bit
%%\footnote{The Keil compiler treats the \Tchar type as signed, just like MSVC and GCC.}.
L'instruction suivante, \TT{LDRSB R0, [R0]} (\q{Load Register Signed Byte}), charge
un octet depuis la mémoire à l'adresse stockée dans \Reg{R0} et étend le signe à
32-bit\footnote{Le compilateur Keil considère le type \Tchar comme signé, tout
comme MSVC et GCC.}.
\myindex{x86!\Instructions!MOVSX}
%%This is similar to the \MOVSX instruction in x86.
Ceci est similaire à l'instruction \MOVSX en x86.

%%The compiler treats this byte as signed since the \Tchar type is signed according to the C standard.
Le compilateur traite cet octet comme signé, puisque le type \Tchar est signé selon
la norme C.
%%It was already written about it~(\myref{MOVSX}) in this section, in relation to x86.
Il a déjà été écrit à propos de cela~(\myref{MOVSX}) dans cette section, en relation
avec le x86.

\myindex{Intel!8086}
\myindex{Intel!8080}
\myindex{ARM}

%%It has to be noted that it is impossible to use 8- or 16-bit part 
%%of a 32-bit register in ARM separately of the whole register,
%%as it is in x86.
Il est à noter qu'il est impossible en ARM d'utiliser séparément la partie 8- ou
16-bit d'un registre 32-bit complet, comme c'est le cas en x86.

%%Apparently, it is because x86 has a huge history of backwards compatibility with its ancestors 
%%up to the 16-bit 8086 and even 8-bit 8080,
%%but ARM was developed from scratch as a 32-bit RISC-processor.
Apparement, c'est parce que le x86 à une énorme histoire de rétro-compatibilité
avec ces ancêtres, jusqu'au 8086 16-bit et même 8080 8-bit, mais ARM a été développé
à partir de zéro comme un processeur RISC 32-bit.

%%Consequently, in order to process separate bytes in ARM, one has to use 32-bit registers anyway.
Par conséquent, pour manipuler des octets séparés en ARM, on doit tout de même utiliser
des registres 32-bit.

%%So, \TT{LDRSB} loads bytes from the string into \Reg{0}, one by one.
%%The following \CMP and \ac{BEQ} instructions check if the loaded byte is 0.
%%If it's not 0, control passes to the start of the body of the loop.
%%And if it's 0, the loop ends.

%%At the end of the function, the difference between 
%%\IT{eos} and \IT{str} is calculated, 1 is subtracted from it, and resulting value is returned
%%via \Reg{0}.

%%N.B. Registers were not saved in this function.
%%\myindex{ARM!\Registers!scratch registers}

%%That's because in the ARM calling convention registers \Reg{0}-\Reg{3} are \q{scratch registers}, 
%%intended for arguments passing,
%%and we're not required to restore their value when the function exits, 
%%since the calling function will not use them anymore.
%%Consequently, they may be used for anything we want.

%%No other registers are used here, so that is why we have nothing to save on the stack.

%%Thus, control may be returned back to calling function by a simple jump (\TT{BX}),
%%to the address in the \ac{LR} register.

\mysubparagraph{\OptimizingXcodeIV (\ThumbMode)}

\lstinputlisting[caption=\OptimizingXcodeIV (\ThumbMode),style=customasmARM]{patterns/10_strings/1_strlen/ARM/xcode_thumb_O3.asm}

%%As optimizing LLVM concludes, \IT{eos} and \IT{str} do not need space on the stack, and can always be stored in registers.

%%Before the start of the loop body, \IT{str} is always in \Reg{0}, 
%%and \IT{eos}---in \Reg{1}.

\myindex{ARM!\Instructions!LDRB.W}
%%The \TT{LDRB.W R2, [R1],\#1} instruction loads a byte from the memory at the address stored in \Reg{1}, to \Reg{2}, sign-extending it to a 32-bit value, but not just that.
%%\TT{\#1} at the instruction's end is implies \q{Post-indexed addressing}, which means that 1 is to be added to \Reg{1} after the byte is loaded.
%%Read more about it: \myref{ARM_postindex_vs_preindex}.

%%Then you can see \CMP and \ac{BNE} in the body of the loop, these instructions continue looping until 0 is found in the string.

\myindex{ARM!\Instructions!MVNS}
\myindex{x86!\Instructions!NOT}
%%\TT{MVNS}\footnote{MoVe Not} (inverts all bits, like \NOT in x86) and \ADD instructions compute $eos - str - 1$.
%%In fact, these two instructions compute $R0 = ~str + eos$, 
%%which is effectively equivalent to what was in the source code, and why it is so, was already explained here
~(\myref{strlen_NOT_ADD}).

%%Apparently, LLVM, just like GCC, concludes that this code can be shorter (or faster).

\mysubparagraph{\OptimizingKeilVI (\ARMMode)}

\lstinputlisting[caption=\OptimizingKeilVI (\ARMMode),label=ARM_leaf_example6,style=customasmARM]{patterns/10_strings/1_strlen/ARM/Keil_ARM_O3.asm}

\myindex{ARM!\Instructions!SUBEQ}

%%Almost the same as what we saw before, with the exception that the $str - eos - 1$ 
%%expression can be computed not at the function's end, but right in the body of the loop.
%%The \TT{-EQ} suffix, as we may recall, implies that the instruction executes only if the operands in
%%the \CMP that has been executed before were equal to each other.
%%Thus, if \Reg{0} contains 0, both \TT{SUBEQ} instructions executes and result is left in the \Reg{0} register.

