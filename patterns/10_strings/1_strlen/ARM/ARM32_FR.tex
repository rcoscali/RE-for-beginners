\myparagraph{ARM 32-bit}

\mysubparagraph{\NonOptimizingXcodeIV (\ARMMode)}

\lstinputlisting[caption=\NonOptimizingXcodeIV (\ARMMode),label=ARM_leaf_example7,style=customasmARM]{patterns/10_strings/1_strlen/ARM/xcode_ARM_O0_FR.asm}

%%Non-optimizing LLVM generates too much code, however, here we can see how the function works with 
%%local variables in the stack.
LLVM sans optimisation génère beaucoup trop de code, toutefois, ici nous pouvons
voir comment la fonction travaille avec les variables locales.
%%There are only two local variables in our function: \IT{eos} and \IT{str}.
Il y a seulement deux variables locales dans notre fonction: \IT{eos} et \IT{str}.
%%In this listing, generated by \IDA, we have manually renamed \IT{var\_8} and \IT{var\_4} to \IT{eos} and \IT{str}.
Dans ce listing, généré par \IDA, nous avons renommé manuellement \IT{var\_8} et
\IT{var\_4} en \IT{eos} et \IT{str}.

%%The first instructions just saves the input values into both \IT{str} and \IT{eos}.
La première instruction sauve simplement les valeurs d'entrée dans \IT{str} et \IT{eos}.

%%The body of the loop starts at label \IT{loc\_2CB8}.
Le corps de la boucle démarre au label \IT{loc\_2CB8}.

%%The first three instruction in the loop body (\TT{LDR}, \ADD, \TT{STR}) load the value of \IT{eos} into \Reg{0}. 
Les trois première instructions du corps de la boucle (\TT{LDR}, \ADD, \TT{STR})
chargent la valeur de \IT{eos} dans \Reg{0}.
%%Then the value is \glslink{increment}{incremented} and saved back into \IT{eos}, which is located in the stack.
Puis la valeur est \glslink{increment}{incrémentée} et sauvée dans \IT{eos}, qui
se trouve sur la pile.

\myindex{ARM!\Instructions!LDRSB}
%%The next instruction,  \TT{LDRSB R0, [R0]} (\q{Load Register Signed Byte}), loads a byte from memory at the address stored in \Reg{0} and sign-extends it to 32-bit
%%\footnote{The Keil compiler treats the \Tchar type as signed, just like MSVC and GCC.}.
L'instruction suivante, \TT{LDRSB R0, [R0]} (\q{Load Register Signed Byte}), charge
un octet depuis la mémoire à l'adresse stockée dans \Reg{R0} et étend le signe à
32-bit\footnote{Le compilateur Keil considère le type \Tchar comme signé, tout
comme MSVC et GCC.}.
\myindex{x86!\Instructions!MOVSX}
%%This is similar to the \MOVSX instruction in x86.
Ceci est similaire à l'instruction \MOVSX en x86.

%%The compiler treats this byte as signed since the \Tchar type is signed according to the C standard.
Le compilateur traite cet octet comme signé, puisque le type \Tchar est signé selon
la norme C.
%%It was already written about it~(\myref{MOVSX}) in this section, in relation to x86.
Il a déjà été écrit à propos de cela~(\myref{MOVSX}) dans cette section, en relation
avec le x86.

\myindex{Intel!8086}
\myindex{Intel!8080}
\myindex{ARM}

%%It has to be noted that it is impossible to use 8- or 16-bit part 
%%of a 32-bit register in ARM separately of the whole register,
%%as it is in x86.
Il est à noter qu'il est impossible en ARM d'utiliser séparément la partie 8- ou
16-bit d'un registre 32-bit complet, comme c'est le cas en x86.

%%Apparently, it is because x86 has a huge history of backwards compatibility with its ancestors 
%%up to the 16-bit 8086 and even 8-bit 8080,
%%but ARM was developed from scratch as a 32-bit RISC-processor.
Apparement, c'est parce que le x86 à une énorme histoire de rétro-compatibilité
avec ses ancêtres, jusqu'au 8086 16-bit et même 8080 8-bit, mais ARM a été développé
à partir de zéro comme un processeur RISC 32-bit.

%%Consequently, in order to process separate bytes in ARM, one has to use 32-bit registers anyway.
Par conséquent, pour manipuler des octets séparés en ARM, on doit tout de même utiliser
des registres 32-bit.

%%So, \TT{LDRSB} loads bytes from the string into \Reg{0}, one by one.
Donc, \TT{LDRSB} charge des octets depuis la chaîne vers \Reg{0}, un par un.
%%The following \CMP and \ac{BEQ} instructions check if the loaded byte is 0.
Les intructions siuvantes, \CMP et \ac{BEQ} vérifié si l'octet chargé est 0.
%%If it's not 0, control passes to the start of the body of the loop.
Si il n'est pas à 0, le contrôle passe au début du corps de la boucle.
%%And if it's 0, the loop ends.
Et si c'est 0, la boucle est terminée.

%%At the end of the function, the difference between 
%%\IT{eos} and \IT{str} is calculated, 1 is subtracted from it, and resulting value is returned
%%via \Reg{0}.
Á la fin de la fonction, la différence entre \IT{eos} et \IT{str} est calculée,
1 en est soustrait, et la valeur résultante est renvoyée via \Reg{0}.

%%N.B. Registers were not saved in this function.
N.B. Les registres n'ont pas été sauvés dans cette fonction.
\myindex{ARM!\Registers!scratch registers}

%%That's because in the ARM calling convention registers \Reg{0}-\Reg{3} are \q{scratch registers}, 
%%intended for arguments passing,
%%and we're not required to restore their value when the function exits, 
%%since the calling function will not use them anymore.
C'est parce que dans la convention d'appel ARM, les registres \Reg{0}-\Reg{3} sont
des \q{registres scratch}, destinés à passer les arguments, et il n'est pas requis
de restaurer leur valeur en sortant de la fonction, puisque  la fonction appelante
ne va plus les utiliser.
%%Consequently, they may be used for anything we want.
Par conséquent, ils peuvent être utilisés comme ien nous semble.

%%No other registers are used here, so that is why we have nothing to save on the stack.
Il n'y a pas d'autres registres utilisés ici, c'est pourquoi nous n'avons rien à
sauvegarder sur la pile.

%%Thus, control may be returned back to calling function by a simple jump (\TT{BX}),
%%to the address in the \ac{LR} register.
Ainsi, le contrôle peut être rendu à la fonction appelante par un simple saut (\TT{BX}),
à l'adresse contenue dans le registre \ac{LR}.

\mysubparagraph{\OptimizingXcodeIV (\ThumbMode)}

\lstinputlisting[caption=\OptimizingXcodeIV (\ThumbMode),style=customasmARM]{patterns/10_strings/1_strlen/ARM/xcode_thumb_O3.asm}

%%As optimizing LLVM concludes, \IT{eos} and \IT{str} do not need space on the stack, and can always be stored in registers.
Comme le conclue LLVM avec l'optimisation, \IT{eos} et \IT{str} n'ont pas besoin
d'espace dans la pile, et peuvent toujours être stockés dans les registres.

%%Before the start of the loop body, \IT{str} is always in \Reg{0}, 
%%and \IT{eos}---in \Reg{1}.
Avant le début du corps de la boucle, \IT{str} est toujours dans \Reg{0}, et
\IT{eos}---dans \Reg{1}.

\myindex{ARM!\Instructions!LDRB.W}
%%The \TT{LDRB.W R2, [R1],\#1} instruction loads a byte from the memory at the address stored in \Reg{1}, to \Reg{2}, sign-extending it to a 32-bit value, but not just that.
L'instruction \TT{LDRB.W R2, [R1],\#1} charge, dans \Reg{2}, un octet de la mémoire
à l'adresse stockée dans \Reg{1}, en étendant le signe à une valeur 32-bit, mais
pas seulement cela.
%%\TT{\#1} at the instruction's end is implies \q{Post-indexed addressing}, which means that 1 is to be added to \Reg{1} after the byte is loaded.
\TT{\#1} à la fin de l'instruction indique un \q[Adressage post-indexé} (\q{Post-indexed addressing}),
qui signife que 1 doit être ajouté à \Reg{1} après avoir chargé l'octet.
%%Read more about it: \myref{ARM_postindex_vs_preindex}.
Pour en lire plus à ce propos: \myref{ARM_postindex_vs_preindex}.

%%Then you can see \CMP and \ac{BNE} in the body of the loop, these instructions continue looping until 0 is found in the string.
Ensuite vous pouvez voir \CMP et \ac{BNE} dans le corps de la boucle, ces instructions
continuent de boucler jusqu'à ce que 0 soit trouvé dans la chaîne.

\myindex{ARM!\Instructions!MVNS}
\myindex{x86!\Instructions!NOT}
%%\TT{MVNS}\footnote{MoVe Not} (inverts all bits, like \NOT in x86) and \ADD instructions compute $eos - str - 1$.
Les instructions \TT{MVNS}\footnote{MoVe Not} (inverse tous les bits, comme \NOT
en x86) et \ADD calculent $eos - str - 1$.
%%In fact, these two instructions compute $R0 = ~str + eos$, 
%%which is effectively equivalent to what was in the source code, and why it is so, was already explained here
~(\myref{strlen_NOT_ADD}).
En fait ces deux instructions calculent $R0 = ~str + eos$, qui est effectivement
équivalent à ce qui est dans le code source, et la raison de ceci à déjà été expliquée
ici ~(\myref{strlen_NOT_ADD}).

%%Apparently, LLVM, just like GCC, concludes that this code can be shorter (or faster).
Apparemment, LLVM, tout comme GCC, conclu que ce code peut être plus court (ou plus
rapide).

\mysubparagraph{\OptimizingKeilVI (\ARMMode)}

\lstinputlisting[caption=\OptimizingKeilVI (\ARMMode),label=ARM_leaf_example6,style=customasmARM]{patterns/10_strings/1_strlen/ARM/Keil_ARM_O3.asm}

\myindex{ARM!\Instructions!SUBEQ}

%%Almost the same as what we saw before, with the exception that the $str - eos - 1$ 
%%expression can be computed not at the function's end, but right in the body of the loop.
Presque la même chose que ce que nous avions vu avant, à l'exception que l'expression
$str - eos - 1$ peut être calculée non pas à la fin de la fonciton, mais dans le
corps de la boucle.
%%The \TT{-EQ} suffix, as we may recall, implies that the instruction executes only if the operands in
%%the \CMP that has been executed before were equal to each other.
%%Thus, if \Reg{0} contains 0, both \TT{SUBEQ} instructions executes and result is left in the \Reg{0} register.
Le suffixe \TT{-EQ}, comme nous devrions nous en souvenir, implique que l'instruction
ne s'exécute que si les opérandes de la dernière instruction \CMP qui a été exécutée
avant étaient égales.
Ainsi, si \Reg{0} contient 0, les deux instructions \TT{SUBEQ} sont exécutées et
le résultat est laissà dans le registre \Reg{0}.
